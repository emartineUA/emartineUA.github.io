{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p>Pr\u00e1cticas de la asignatura Metodolog\u00edas \u00c1giles de Desarrollo de Software de la Universidad de Alicante.</p> <ul> <li>Pr\u00e1ctica 1<ul> <li>Enunciado de la pr\u00e1ctica</li> <li>Introducci\u00f3n a Spring Boot</li> <li>Resumen de comandos Git</li> </ul> </li> </ul>"},{"location":"index.html#construido-con-mkdocs","title":"Construido con MkDocs","text":"<p>Versi\u00f3n HTML compilada usando el tema Material de MkDocs.</p> <p>Repositorio en GitHub.</p>"},{"location":"01-intro-spring-boot/comandos-git.html","title":"Resumen de comandos Git","text":"<p>Comandos principales para trabajar con Git de forma individual. Los comandos relacionados con el trabajo en equipo los veremos en la pr\u00e1ctica 2.</p> <p>Al final del documento se incluyen enlaces a apartados del libro Pro Git. Es un libro totalmente recomendable, deber\u00edas baj\u00e1rtelo y guardarlo como material de aprendizaje y de referencia. Est\u00e1 disponible de forma gratuita en m\u00faltiples versiones (PDF, eBook, HTML y mobi).</p>"},{"location":"01-intro-spring-boot/comandos-git.html#1-comandos-basicos","title":"1. Comandos b\u00e1sicos","text":"<ul> <li> <p>Configurar el usuario y direcci\u00f3n de correo en git:</p> <pre><code>$ git config --global user.name \"John Doe\"\n$ git config --global user.email johndoe@example.com\n</code></pre> </li> <li> <p>Inicializar git en un directorio:</p> <pre><code>$ cd /ruta/a/mi/directorio\n$ git config --global user.name &lt;nombre-usuario&gt;\n$ git config --global user.email &lt;email&gt;\n$ git init\n$ git add .\n$ git commit -m \"Versi\u00f3n inicial\"\n</code></pre> </li> <li> <p>Publicar por primera vez el repositorio local en el remoto (en GitHub):</p> <pre><code>$ git remote add origin &lt;url-repo&gt;.git\n$ git push -u origin main\n</code></pre> <p>El nombre del repositorio remoto ser\u00e1 <code>origin</code> (nombre est\u00e1ndar del repositorio remoto en el caso en el que s\u00f3lo haya uno). Subimos al repositorio la rama <code>main</code> (la rama por defecto que se crea al inicializar el repositorio local).</p> </li> <li> <p>Comprobar el estado del repositorio local: </p> <pre><code>$ git status\n</code></pre> </li> <li> <p>Comprobar las diferencias entre los ficheros modificados en el   directorio de trabajo y el \u00faltimo commit:</p> <pre><code>$ git diff\n</code></pre> </li> <li> <p>A\u00f1adir un fichero al   stage   (a\u00f1adirlo para el pr\u00f3ximo commit):</p> <pre><code>$ git add &lt;fichero o directorio&gt;\n</code></pre> <p>El \u00e1rea de stage tambi\u00e9n se llama el index. Es muy importante entender su funcionamiento para trabajar con Git. El siguiente dibujo muestra su funcionamiento:</p> <p></p> </li> <li> <p>Hacer un commit de los ficheros en el stage:</p> <pre><code>$ git commit -m \"Mensaje\"\n</code></pre> </li> <li> <p>Eliminar un fichero del stage (si lo hemos a\u00f1adido, pero al final   decidimos no a\u00f1adirlo en el siguiente commit):</p> <pre><code>$ git reset HEAD &lt;fichero&gt;\n</code></pre> </li> <li> <p>Se puede combinar en un \u00fanico comando el <code>add</code> y el <code>commit</code> en   ficheros ya a\u00f1adidos al control de versiones:</p> <pre><code>$ git commit -a -m \"Mensaje\"\n</code></pre> <p>Se puede abreviar como </p> <pre><code>$ git commit -am \"Mensaje\"`\n</code></pre> </li> <li> <p>Deshacer un commit (sin perder los cambios que se han introducido en \u00e9l):</p> <pre><code>$ git reset HEAD^\n</code></pre> <p>Los ficheros modificados seguir\u00e1n estando en el directorio, con las modificaciones incluidas, pero fuera del \u00e1rea de stage. Para hacer un nuevo commit hay que volver a a\u00f1adirlos haciendo <code>add</code>.</p> </li> <li> <p>Eliminar todos los cambios realizados en el directorio, volviendo al   \u00faltimo commit (\u00a1Peligroso: perdemos todos los cambios del \u00faltimo commit!)</p> <pre><code>$ git reset --hard HEAD\n$ git clean -fd (si se ha a\u00f1adido alg\u00fan fichero)\n</code></pre> </li> <li> <p>Publicar los cambios en el repositorio remoto:</p> <pre><code>$ git push\n</code></pre> </li> <li> <p>Si hay commits en el repositorio remoto que queremos eliminar y cambiarlos por   los commits en el directorio local:</p> <pre><code>$ git push --force\n</code></pre> </li> <li> <p>Consultar los mensajes de los commits (toda la historia de la rama   actual). La opci\u00f3n <code>--oneline</code> muestra s\u00f3lo la primera l\u00ednea del   mensaje, la opci\u00f3n <code>--graph</code> muestra el grafo de dependencias y la   opci\u00f3n <code>--all</code>muestra el grafo completo, no s\u00f3lo aquel en el que   estamos (<code>HEAD</code>).</p> <pre><code>$ git log [--oneline] [--graph] [--all]\n</code></pre> </li> <li> <p>Comprobar las diferencias entre dos commits:</p> <pre><code>$ git diff &lt;hash-previo&gt; &lt;hash-nuevo&gt;\n</code></pre> <p>Devuelve las cambios que se han introducido desde el commit identificado por  y hasta el ."},{"location":"01-intro-spring-boot/comandos-git.html#2-ramas","title":"2. Ramas","text":"<p>Es muy importante entender que las ramas en Git son como etiquetas m\u00f3viles. La rama en la que estamos se actualiza de posici\u00f3n cada vez que hacemos un nuevo commit. Git mantiene en la referencia <code>HEAD</code> la rama actual.</p> <p></p> <ul> <li> <p>Crear una rama nueva:</p> <pre><code>$ git checkout -b nueva-rama\nM   hola.txt (si hay cambios en el espacio de trabajo se llevan a la nueva rama)\nSwitched to a new branch 'nueva-rama'\n</code></pre> </li> <li> <p>Listar todas las ramas de un repositorio (incluyendo ramas remotas)</p> <pre><code>$ git branch -av\nmain\n* nueva-rama\n$ git commit -a -m \"Confirmamos los cambios en la nueva rama\"\n</code></pre> </li> <li> <p>Moverse a otra rama:</p> <pre><code>$ git checkout main\nSwitched to branch 'main'\n</code></pre> </li> <li> <p>Mostrar un fichero de una rama (o commit) dado:</p> <pre><code>$ git show &lt;commit o rama&gt;:&lt;nombre-fichero&gt;\n</code></pre> </li> <li> <p>Comparar dos ramas:</p> <pre><code>$ git diff main nueva-rama\n</code></pre> <p>El comando <code>git diff main nueva-rama</code> devuelve las diferencias entre las ramas <code>main</code> y <code>nueva-rama</code>: las modificaciones que resultar\u00edan de mezclar la rama <code>nueva-rama</code> en la rama <code>main</code>.</p> </li> <li> <p>Merge de ramas: Mezclar la rama <code>nueva-rama</code> en la rama <code>main</code> (a\u00f1ade a la <code>main</code> los commits adicionales de la rama <code>nueva-rama</code>):</p> <pre><code>$ git checkout main\n$ git merge [--no-ff] nueva-rama -m \"Mensaje de commit\"\n</code></pre> <p>La opci\u00f3n <code>--no-ff</code> no hace un fast forward y mantiene separados los commits de la rama en el log de commits. Es \u00fatil para revisar la historia del repositorio.</p> </li> <li> <p>Si en la rama que se mezcla y en la actual hay cambios que afectan a   las mismas l\u00edneas de un fichero, git detecta un conflicto y combina   esas l\u00edneas conservando las dos versiones y a\u00f1adiendo la informaci\u00f3n   de la procedencia. Debemos resolver el conflicto: editarlos a mano y   volver a hacer add y commit.</p> <pre><code>$ git merge nueva-rama\nCONFLICT (content): Merge conflict in hola.txt  \nAutomatic merge failed; fix conflicts and then commit the result.  \n# editar a mano el fichero con conflictos\n$ git commit -a -m \"Arreglado el conflicto en el merge\"\n$ git merge nueva-rama\n</code></pre> <p>El comando <code>git status</code> despu\u00e9s de un merge nos indica qu\u00e9 ficheros no se han mezclado y hay que editar manualmente.</p> </li> <li> <p>Rebase de una rama. Si la rama main ha avanzado despu\u00e9s de   separar una rama alternativa y queremos incorporar esos cambios en   la rama alternativa podemos hacer un <code>git rebase</code>:</p> <pre><code>$ git checkout -b experiment\n# hacemos cambios\n$ git commit -m \"Cambios en experiment\"\n$ git checkout main  \n# hacemos cambios  \n$ git commit -a -m \"Cambios en main\"  \n$ git checkout experiment\n$ git rebase main  \nFirst, rewinding head to replay your work on top of it...  \nApplying: Corregido bug1  \nApplying: Corregido bug2\n</code></pre> <p></p> <p>El comando cambia la historia de la rama: primero la mueve al final de la rama main (rewind head) y a partir de ah\u00ed aplica los cambios propios de la rama.</p> <p>\u00a1Cuidado!</p> <p>No se debe hacer un rebase de commits que existan en otros repositorios locales de compa\u00f1eros. Al volver a aplicar los commits sobre los commits rebobinados, se cambia su n\u00famero de hash (identificador) y se convierten en commits distintos.</p> <p>Una vez que hemos hecho el rebase ya podemos a\u00f1adir mover la rama <code>main</code> y tener una historia lineal:</p> <pre><code>$ git checkout main\n$ git merge nueva-rama\n# Borramos la rama una vez mezclada\n$ git branch -d nueva-rama\n</code></pre> </li> <li> <p>Igual que en el merge, al hacer un rebase pueden aparecer   conflictos al hacer el rebase, basta con modificar los ficheros   con conflictos, a\u00f1adirlos y continuar el rebase:</p> <pre><code>$ git rebase main\nCONFLICT (content): Merge conflict in &lt;some-file&gt;\n# hacemos git status para comprobar donde est\u00e1n los conflictos\n$ git status\n# Unmerged paths:\n# (use \"git reset HEAD &lt;some-file&gt;...\" to unstage)\n# (use \"git add/rm &lt;some-file&gt;...\" as appropriate to mark resolution)\n#\n# Editamos los ficheros para corregir los conflictos\n$ git add &lt;some-file&gt;\n$ git rebase --continue\n</code></pre> <p>Nota</p> <p>Es posible integrar los cambios de una rama haciendo un merge o haciendo un rebase. Ambas estrategias son correctas y cada una tiene sus pros y contras. Nosotros vamos a usar ambas para aprender su funcionamiento.</p> </li> <li> <p>Log en forma de grafo:</p> <pre><code>$ git log --graph --oneline \n</code></pre> </li> <li> <p>Borrar una rama:</p> <pre><code>$ git branch -d nueva-rama  \nDeleted branch nueva-rama (was c241d7b)\n</code></pre> <p>S\u00f3lo podemos borrar de la forma anterior ramas en las que no estamos y que se han mezclado con alguna otra. El comando anterior no permite borrar ramas activas que tienen commits sin mezclar con otras.</p> </li> <li> <p>Borrar una rama descartando sus commits:</p> <pre><code>$ git branch -D rama\n</code></pre> </li> <li> <p>Subir una rama al repositorio remoto:</p> <pre><code>$ git push -u origin &lt;rama&gt;\n</code></pre> </li> <li> <p>Descargar una rama del repositorio remoto (origin, por ejemplo, el   repositorio remoto por defecto)</p> <pre><code>$ git fetch \n$ git checkout -b &lt;rama&gt; origin/&lt;rama&gt;\n</code></pre> </li> <li> <p>Consultar ramas locales y conexiones repositorio remoto (origin, por ejemplo)</p> <pre><code>$ git remote show origin\n</code></pre> </li> <li> <p>Subir todas las ramas y etiquetas:</p> <pre><code>$ git push -u -all origin\n</code></pre> <p>Al poner la opci\u00f3n -u hacemos tracking del repositorio remoto y las referencias quedan almacenadas en el fichero de configuraci\u00f3n .git/config. A partir de ahora s\u00f3lo es necesario hacer <code>git push</code> para subir los cambios en cualquiera de las ramas presentes.</p> </li> <li> <p>Borrar una rama en repositorio remoto:</p> <pre><code>$ git push origin --delete &lt;branchName&gt;\n</code></pre> </li> </ul>"},{"location":"01-intro-spring-boot/comandos-git.html#3-modificar-la-historia","title":"3. Modificar la historia","text":"<ul> <li> <p>Modificar el mensaje del \u00faltimo commit. Se abrir\u00e1 un editor en el   que modificar el mensaje. Tambi\u00e9n se puede escribir el mensaje a   mano:</p> <pre><code>$ git commit --amend [--m \"Nuevo mensaje\"]\n</code></pre> </li> <li> <p>Deshacer el \u00faltimo commit (s\u00f3lo la acci\u00f3n del commit, dejando los cambios en el stage):</p> <pre><code>$ git reset --soft HEAD^\n</code></pre> </li> <li> <p>Descartar el \u00faltimo merge y volver a la situaci\u00f3n anterior al hacer el merge:</p> <pre><code>$ git reset --merge ORIG_HEAD\n</code></pre> </li> <li> <p>Movernos atr\u00e1s a un commit pasado, mirar los ficheros, crear una   nueva rama all\u00ed (o no) y volver al commit actual:</p> <pre><code>$ git checkout &lt;hash&gt; (o tag, por ejemplo v2.0)\nYou are in 'detached HEAD' state.\n# Ahora est\u00e1s en un detached HEAD\n$ git branch\n* (HEAD detached at 594b606)\nmain\n$ git checkout -b v2.0.1\nSwitched to a new branch 'v2.0.1'\n$ git branch\nmain\n* v2.0.1\n$ git checkout main\n</code></pre> </li> <li> <p>Movernos atr\u00e1s a un commit pasado, descartando todos los commits   realizados despu\u00e9s (peligroso)</p> <pre><code>$ git reset --hard &lt;hash&gt;\n</code></pre> </li> </ul>"},{"location":"01-intro-spring-boot/comandos-git.html#4-mas-informacion","title":"4. M\u00e1s informaci\u00f3n","text":"<p>Puedes encontrar m\u00e1s informaci\u00f3n en los siguientes documentos:</p> <ul> <li>Pro Git - Recording Changes to the Repository</li> <li>Pro Git - Basic Branching and Merging</li> <li>Pro Git - Git Branching - Rebasing</li> <li>Tutorial de Atlassian - Merging vs. Rebasing</li> <li>Pro Git - Reset Demystified</li> </ul>"},{"location":"01-intro-spring-boot/intro-spring-boot.html","title":"Introducci\u00f3n a Spring Boot","text":"<p>Vamos a trabajar con la versi\u00f3n 2.7.14 de Spring Boot. Se puede consultar toda la documentaci\u00f3n oficial sobre esta versi\u00f3n en este enlace. </p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#1-aplicacion-ejemplo","title":"1. Aplicaci\u00f3n ejemplo","text":"<p>Es muy sencillo crear aplicaciones de Spring Boot desde cero usando la web Spring initializr. En esa p\u00e1gina puedes configurar los metadatos del proyecto y sus dependencias y descargar el proyecto como un ZIP con la estructura de directorios y el POM ya configurados. </p> <p>Nosotros vamos a hacerlo m\u00e1s f\u00e1cil todav\u00eda usando una aplicaci\u00f3n ejemplo en GitHub domingogallardo/spring-boot-demoapp. </p> <p>La aplicaci\u00f3n es un sencillo <code>Hola mundo</code>. En los siguientes apartados explicamos c\u00f3mo lanzarla y c\u00f3mo funciona.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#2-ejecucion-de-aplicaciones-spring-boot","title":"2. Ejecuci\u00f3n de aplicaciones Spring Boot","text":"<p>Spring Boot permite ejecutar aplicaciones Spring de forma standalone, sin necesidad de un servidor de aplicaciones. Una aplicaci\u00f3n Spring Boot lleva incluido un servidor web embebido (Tomcat) que se pone en marcha al lanzar la aplicaci\u00f3n y sirve todas las p\u00e1ginas de la aplicaci\u00f3n web.</p> <p>Para lanzar una aplicaci\u00f3n Spring Boot es suficiente tener instalados:</p> <ul> <li>JDK Java (8 en adelante)</li> <li>Maven</li> </ul> <p>Maven incluso no es necesario si la aplicaci\u00f3n Spring Boot lo tiene ya instalado utilizando Maven Wrapper, como es el caso de la aplicaci\u00f3n ejemplo.</p> <p>Desde el directorio donde est\u00e1 la aplicaci\u00f3n que queremos lanzar podemos arrancarla como una aplicaci\u00f3n Java. Podemos llamar a <code>mvn</code> si tenemos instalado Maven o a <code>./mvnw</code> para usar Maven Wrapper:</p> <pre><code>$ ./mvnw package\n$ java -jar target/demoapp-0.0.1-SNAPSHOT.jar \n</code></pre> <p>Tambi\u00e9n podemos lanzarla usando el plugin <code>spring-boot</code> de Maven:</p> <pre><code>$ ./mvnw spring-boot:run\n</code></pre> <p>La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio.</p> <p>En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas:</p> <ul> <li>http://localhost:8080</li> <li>http://localhost:8080/saludo/Pepito</li> <li>http://localhost:8080/saludoplantilla/Pepito</li> <li>http://localhost:8080/saludoform</li> </ul>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#3-desarrollo-y-ejecucion-con-intellij","title":"3. Desarrollo y ejecuci\u00f3n con IntelliJ","text":"<p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p> <p>Para abrir un proyecto Spring Boot en IntelliJ basta con abrir el directorio donde se encuentre el fichero <code>pom.xml</code>. Se puede hacer desde la pantalla de bienvenida de IntelliJ con la opci\u00f3n Open o usando la opci\u00f3n File &gt; Open\" o \"File &gt; New &gt; Project from Existing Sources. </p> <p>IntelliJ abre el proyecto correctamente:</p> <p></p> <p>Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n:</p> <p></p> <p>Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:</p> <p></p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#github-copilot","title":"GitHub Copilot","text":"<p>Es recomendable instalar el plugin GithHub Copilot para JetBrains para trabajar con este asistente de IA como ayudante de c\u00f3digo. Tras instalar el plugin deber\u00e1s activarlo introduciendo tu usuario de GitHub.</p> <p>Puedes trabajar de forma gratuita con GitHub Copilot d\u00e1ndote de alta en el GitHub Student Developer Pack.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#4-conceptos-de-spring-boot","title":"4. Conceptos de Spring Boot","text":""},{"location":"01-intro-spring-boot/intro-spring-boot.html#estructura-de-la-aplicacion","title":"Estructura de la aplicaci\u00f3n","text":"<p>Estructura de directorios t\u00edpica de los proyectos Java construidos con Maven:</p> <p></p> <p>El fichero <code>pom.xml</code> declara las dependencias. Spring Boot proporciona starters que agrupan un conjunto de dependencias comunes.</p> <p>Fichero <code>pom.xml</code></p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0\n         https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;es.ua.mads&lt;/groupId&gt;\n    &lt;artifactId&gt;demoapp&lt;/artifactId&gt;\n    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n    &lt;name&gt;demoapp&lt;/name&gt;\n\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;2.6.10&lt;/version&gt;\n    &lt;/parent&gt;\n\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n    &lt;/dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n                &lt;configuration&gt;\n                    &lt;argLine&gt;-Dfile.encoding=UTF8&lt;/argLine&gt;\n                &lt;/configuration&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n\n&lt;/project&gt;\n</code></pre> <p>En el panel de Maven de IntelliJ se puede consultar las librer\u00edas concretas que se han descargado:</p> <p></p> <p>En el fichero de configuraci\u00f3n de la aplicaci\u00f3n se definen propiedades que configuran distintos aspectos de la misma, como la base de datos con la que se va a trabajar o el puerto en el que debe ejecutarse. Conforme necesitemos configurar estas propiedades iremos a\u00f1adiendo elementos al fichero.</p> <p>Fichero <code>resources/application.properties</code></p> <pre><code>spring.application.name = demoapp\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#controladores","title":"Controladores","text":"<p>Los controladores definen el c\u00f3digo a ejecutar como respuesta a una petici\u00f3n HTTP. Son clases que se suelen colocar en el paquete <code>controller</code> y est\u00e1n anotadas con <code>@Controller</code>.</p> <p>Vemos un ejemplo en la clase <code>SaludoController</code>.</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoController.java</code>:</p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n\n@Controller\npublic class SaludoController {\n\n    @Autowired\n    private SaludoService service;\n\n    @RequestMapping(\"/saludo/{nombre}\")\n    public @ResponseBody String saludo(@PathVariable(value=\"nombre\") String nombre) {\n        return service.saluda(nombre);\n    }\n\n}\n</code></pre> <p>Los m\u00e9todos en los que se definen las respuestas a las peticiones HTTP est\u00e1n anotados con anotaciones en las que se indica el tipo de petici\u00f3n y la URL a la que se responde.</p> <p>Por ejemplo, en la clase anterior el m\u00e9todo <code>saludo</code> contesta a las peticiones dirigida a la URL <code>/saludo/Ana</code>. La cadena <code>Ana</code> en la URL es decodificada y pasada en el par\u00e1metro <code>nombre</code> al m\u00e9todo.</p> <p>El m\u00e9todo devuelve la respuesta HTTP. La anotaci\u00f3n <code>@ResponseBody</code> construye autom\u00e1ticamente esta respuesta, a\u00f1adiendo como contenido de la misma la cadena devuelta por el servicio. </p> <p>En este caso la respuesta es:</p> <pre><code>HTTP/1.1 200 \nContent-Type: text/plain;charset=UTF-8\nContent-Length: 8\nDate: Mon, 02 Sep 2019 14:59:04 GMT\n\nHola Ana\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#clases-de-servicio","title":"Clases de Servicio","text":"<p>Es recomendable definir clases de servicio en las que se implementa la l\u00f3gica de negocio de la aplicaci\u00f3n. Las clases controller llaman a las clases servicio, que son las que realmente realizan todo el procesamiento.</p> <p>De esta forma se separan las responsabilidades. Las clases controller se encargan de procesar las peticiones y las respuestas HTTP y las clases de servicio son las que realmente realizan la l\u00f3gica de negocio y devuelven el contenido de las respuestas. Si en alg\u00fan momento hay que a\u00f1adir una nueva capa de presentaci\u00f3n en la que, por ejemplo, se trabaje con objetos JSON, no ser\u00e1 necesario cambiar la capa de servicios, s\u00f3lo a\u00f1adir nuevas clases controller.</p> <p>La separaci\u00f3n de la l\u00f3gica de negocio en las clases de servicio permite tambi\u00e9n realizar tests que trabajan sobre objetos Java, independientes de los formatos de entrada/salida manejados por los controladores. </p> <p>Fichero <code>src/main/java/demoapp/service/SaludoService.java</code></p> <pre><code>package demoapp.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class SaludoService {\n    public String saluda(String nombre) {\n        return \"Hola \" + nombre;\n    }\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#inyeccion-de-dependencias-en-spring","title":"Inyecci\u00f3n de dependencias en Spring","text":"<p>Spring Boot utiliza la anotaci\u00f3n <code>@Autowired</code> para inyectar en la variable anotada un objeto nuevo del tipo indicado. Se puede definir la anotaci\u00f3n en la variable o en el constructor de la clase. Hemos utilizado la anotaci\u00f3n en las variables de instancia.</p> <p>En los ejemplos anteriores podemos comprobar estas anotaciones. En la aplicaci\u00f3n ejemplo se define un controlador y un servicio que devuelve un saludo. El servicio se anota con la anotaci\u00f3n <code>@Service</code> y esta anotaci\u00f3n le indica a Spring Boot que la clase que va a poder ser inyectada.</p> <p>En el controlador se necesita instanciar un objeto de la clase <code>SaludoService</code> y se hace usando inyecci\u00f3n de dependencias. Spring Boot se encarga de obtener una instancia y de inyectarla en la variable cuando se inicializa el controlador. Lo vemos en el siguiente c\u00f3digo:</p> <pre><code>@Controller\npublic class SaludoController {\n\n    @Autowired\n    private SaludoService service;\n\n    @RequestMapping(\"/saludo/{nombre}\")\n    public @ResponseBody String saludo(@PathVariable(value=\"nombre\") String nombre) {\n        return service.saluda(nombre);\n    }\n\n}\n</code></pre> <p>Mediante la inyecci\u00f3n de dependencias el c\u00f3digo es m\u00e1s flexible y es m\u00e1s f\u00e1cil de testear, pudi\u00e9ndose definir mocks que sustituyen los objetos inyectados.</p> <p>M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Spring Boot Spring Beans and Dependency Injection.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#alcance-de-los-objetos-inyectados","title":"Alcance de los objetos inyectados","text":"<p>Por defecto el alcance (scope) de todas las anotaciones de Spring (<code>@service</code>, <code>@controller</code>, <code>@component</code>, etc.) es un Singleton. Existe una \u00fanica instancia de ese objeto que es la que se inyecta en las variables.</p> <p>Al estar funcionando en una aplicaci\u00f3n web, el singleton que hace de controlador recibir\u00e1 m\u00faltiples peticiones concurrentemente. Cada petici\u00f3n ir\u00e1 en su propio hilo de Java, por lo que m\u00faltiples hilos podr\u00e1n estar ejecutando el mismo c\u00f3digo del controlador. </p> <p>Por ello hay que tener cuidado en no definir variables de instancia mutables (con estado) dentro del controlador (con excepci\u00f3n de los objetos inyectados con la anotaci\u00f3n <code>@Autowired</code>), porque podr\u00edan producirse errores debidos a condiciones de carrera (un hilo modifica la misma variable que otro est\u00e1 leyendo). Es conveniente que todos los beans (controladores, servicios, etc.) sean objetos sin estado.</p> <p>Tambi\u00e9n es posible definir otros alcances, como <code>@RequestScope</code> o <code>@SessionScope</code>. En el primer caso se crea una instancia nueva del objeto para cada petici\u00f3n HTTP y en el segundo se crea una instancia nueva en cada sesi\u00f3n HTTP.</p> <p>Puedes encontrar m\u00e1s informaci\u00f3n y ejemplos en este enlace.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#plantillas-thymeleaf","title":"Plantillas Thymeleaf","text":"<p>Las p\u00e1ginas HTML devueltas se pueden construir utilizando un lenguaje de plantillas con el framework Thymeleaf. Las plantillas thymeleaf son p\u00e1ginas HTML en las que se introducen objetos Java pasados por los controllers.</p> <p>Las plantillas se incluyen en el directorio <code>resources/templates</code>.</p> <p>Por ejemplo, el siguiente fichero es una sencilla plantilla que muestra un saludo. El objeto <code>mensaje</code> es una cadena que se pasa desde el controller.</p> <p>Fichero <code>src/main/resources/templates/saludo.html</code></p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n    &lt;h1 th:text=\"'Saludo: ' + ${mensaje}\"&gt; &lt;/h1&gt;\n&lt;/html&gt;\n</code></pre> <p>El controller construye la vista devolviendo el nombre de la plantilla. Y pasa a la plantilla los objetos a mostrar usando un diccionario (la variable <code>model</code> que recibe como par\u00e1metro):</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoControllerPlantilla.java</code></p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n\n@Controller\npublic class SaludoControllerPlantilla {\n\n    @Autowired\n    private SaludoService service;\n\n    @RequestMapping(\"/saludoplantilla/{nombre}\")\n    public String saludo(@PathVariable(value=\"nombre\") String nombre, \n                                                       Model model) {\n        // Se a\u00f1ade la respuesta a la clave 'mensaje' que se usa\n        // en la plantilla\n        model.addAttribute(\"mensaje\", service.saluda(nombre));\n        // Se llama a la plantilla 'saludo.html'\n        return \"saludo\";\n    }\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#formularios-y-validacion","title":"Formularios y validaci\u00f3n","text":"<p>Spring Boor simplifica la declaraci\u00f3n y validaci\u00f3n de formularios usando clases Java que trabajan como modelos del formulario. Por ejemplo, en la aplicaci\u00f3n se define la clase <code>UserData</code>:</p> <p>Fichero <code>src/main/java/demoapp/controller/UserData.java</code></p> <pre><code>package demoapp.controller;\n\nimport javax.validation.constraints.Size;\n\npublic class UserData {\n    @Size(min=3, max=30)\n    String nombre;\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n}\n</code></pre> <p>Se trata de un objeto con el campo <code>nombre</code> de tipo <code>String</code> al que se le ha a\u00f1adido una anotaci\u00f3n de validaci\u00f3n <code>@Size</code> con el tama\u00f1o m\u00ednimo y m\u00e1ximo que debe tener.</p> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre otros atributos de validaci\u00f3n en este enlace.</p> <p>El formulario HTML propiamente dicho se define con una plantilla thymeleaf en la que se declara un objeto que tiene el mismo nombre que el nombre de la clase modelo, pero con la primera letra en min\u00fascula. En nuestro caso la clase modelo es <code>UserData</code>, por lo que el objeto del formulario debe llamarse <code>userData</code>. En el formulario podemos usar cualquier campo definido en el objeto modelo. En nuestro caso usamos el \u00fanico campo de tipo <code>String</code>, <code>nombre</code>.</p> <p>Fichero <code>src/main/resources/templates/formRegistro.html</code></p> <pre><code>&lt;!DOCTYPE HTML&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n&lt;body&gt;\n&lt;form th:action=\"@{/saludoform}\" th:object=\"${userData}\" method=\"post\"&gt;\n    &lt;table&gt;\n        &lt;tr&gt;\n            &lt;td&gt;Nombre:&lt;/td&gt;\n            &lt;td&gt;&lt;input type=\"text\" th:field=\"*{nombre}\" /&gt;&lt;/td&gt;\n            &lt;td th:if=\"${#fields.hasErrors('nombre')}\" th:errors=\"*{nombre}\"&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n        &lt;tr&gt;\n            &lt;td&gt;&lt;button type=\"submit\"&gt;Enviar&lt;/button&gt;&lt;/td&gt;\n        &lt;/tr&gt;\n    &lt;/table&gt;\n&lt;/form&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Se define una acci\u00f3n que enviar\u00e1 una petici\u00f3n <code>POST</code> a la URL <code>/saludoform</code> con los datos del formulario. En este caso el nombre.</p> <p>Por \u00faltimo, el controller que lanza el formulario y el que recibe la petici\u00f3n <code>POST</code> con los datos introducidos se definen en el siguiente fichero:</p> <p>Fichero <code>src/main/java/demoapp/controller/SaludoControllerForm.java</code></p> <pre><code>package demoapp.controller;\n\nimport demoapp.service.SaludoService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\n\n@Controller\npublic class SaludoControllerForm {\n\n    @Autowired\n    private SaludoService service;\n\n    @GetMapping(\"/saludoform\")\n    // Hay que declarar un par\u00e1metro con el tipo usado en el modelo del formulario (UserData)\n    public String saludoForm(UserData userData) {\n        return \"formRegistro\";\n    }\n\n    @PostMapping(\"/saludoform\")\n    public String checkPersonInfo(@ModelAttribute @Valid UserData userData, BindingResult bindingResult, Model model) {\n        if (bindingResult.hasErrors()) {\n            return \"formRegistro\";\n        }\n        model.addAttribute(\"mensaje\", service.saluda(userData.getNombre()));\n        return \"saludo\";\n    }\n}\n</code></pre> <p>El m\u00e9todo que recibe la petici\u00f3n en <code>/saludoform</code> simplemente devuelve la plantilla con el formulario. </p> <p>Y el m\u00e9todo que recibe los datos es el que responde a la petici\u00f3n <code>POST</code> en la URL <code>/saludoform</code> recibe los datos del formulario en un objeto Java del tipo del modelo del formulario (el par\u00e1metro <code>userData</code>). Las anotaciones <code>@ModelAttribute</code> y <code>@Valid</code> indican que es un objeto recogido en el formulario sobre el que se ha realizado una validaci\u00f3n. Se detecta si ha habido alg\u00fan error en el m\u00e9todo <code>hasErrors()</code> del <code>bindingResult</code> que se recibe tambi\u00e9n como par\u00e1metro. </p> <p>Si ha habido error, se vuelve a devolver el formulario para que se vuelva a completar. Si no ha habido error se obtiene el nombre introducido en el formulario y se pasa a la plantilla del saludo.</p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests","title":"Tests","text":"<p>A partir de Spring Boot 2.4 se usa JUnit 5 como librer\u00eda de tests.</p> <p>En la aplicaci\u00f3n de demostraci\u00f3n hay varios ejemplos que muestran posibles formas de realizar pruebas en una aplicaci\u00f3n Spring Boot.</p> <p>Spring Boot incluye el framework AssertJ que permite realizar expresiones de prueba con un lenguaje muy expresivo.</p> <p>Los tests se pueden ejecutar usando el comando t\u00edpico de Maven:</p> <pre><code>$ mvn test\n</code></pre> <p>O tambi\u00e9n, usando el comando de Maven Wrapper:</p> <pre><code>$ ./mvnw test\n</code></pre> <p>Tambi\u00e9n se pueden lanzar desde el propio IntelliJ, pulsando en el panel del proyecto sobre el directorio de tests con el bot\u00f3n derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se mostrar\u00e1 si pasan correctamente (verde) o no.</p> <p></p>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests-sobre-clases-de-servicio","title":"Tests sobre clases de servicio","text":"<p>Podemos realizar pruebas sobre la capa de servicio, obteniendo una instancia del servicio mediante inyecci\u00f3n de dependencias.</p> <p>En el siguiente ejemplo se muestra c\u00f3mo se prueba el m\u00e9todo de servicio <code>saluda</code>.</p> <p>Fichero <code>src/test/java/demoapp/ServiceTest.java</code></p> <pre><code>package demoapp;\n\nimport demoapp.service.SaludoService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@SpringBootTest\npublic class ServiceTest {\n\n    @Autowired\n    SaludoService saludo;\n\n    @Test\n    public void contexLoads() throws Exception {\n        assertThat(saludo).isNotNull();\n    }\n\n    @Test\n    public void serviceSaludo() throws Exception {\n        assertThat(saludo.saluda(\"Domingo\")).isEqualTo(\"Hola Domingo\");\n    }\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#tests-sobre-capa-web","title":"Tests sobre capa web","text":"<p>Es posible realizar tests sobre la capa de presentaci\u00f3n sin lanzar realmente el servidor web ni ejecutar realmente las peticiones HTTP. Se obtiene por inyecci\u00f3n de dependencias un mock de la clase <code>MockMvc</code> y se usan m\u00e9todos como <code>perform(get(\"/\"))</code> o <code>perform(post(\"/saludoform\").param(\"nombre\", \"Domingo\"))</code>.</p> <p>En el primer test del ejemplo siguiente se comprueba que una petici\u00f3n <code>GET</code> a la URL <code>/</code> devuelve un c\u00f3digo HTTP OK (200) y una p\u00e1gina HTML con la cadena esperada.</p> <p>En este test lo \u00fanico que se moquea es el servidor web, y se ejecuta el c\u00f3digo real del servicio, del controlador y de la plantilla.</p> <p>Se utilizan los m\u00e9todos <code>andDo</code> y <code>andExpect</code> de la propia librer\u00eda de testeo de Spring Framework y el m\u00e9todo <code>conteainsString</code> de la librer\u00eda de testeo Hamcrest.</p> <p>En el segundo test se realiza una petici\u00f3n <code>POST</code> para comprobar que el formulario funciona correctamente.</p> <p>Fichero <code>src/test/demoapp/MockMvcTest.java</code></p> <pre><code>package demoapp;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class MockMvcTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    // Hacemos una petici\u00f3n GET a un end point y comprobamos que\n    // el HTML resultante es correcto\n    @Test\n    public void shouldReturnDefaultMessage() throws Exception {\n        this.mockMvc.perform(get(\"/\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(containsString(\"Hello World\")));\n    }\n\n    // Podemos hacer tambi\u00e9n una petici\u00f3n POST y pasar los datos\n    // del formulario con el m\u00e9todo .param\n    @Test\n    public void postShoudReturnCorrectResponse() throws Exception {\n        this.mockMvc.perform(post(\"/saludoform\")\n                .param(\"nombre\", \"Domingo\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(containsString(\"Hola Domingo\")));\n    }\n}\n</code></pre> <p>Tambi\u00e9n es posible realizar un test \u00fanicamente del controlador y la plantilla de presentaci\u00f3n, moqueando el servicio. Se muestra en el fichero <code>MockServiceTest</code>.</p> <p>Fichero <code>src/test/demoapp/MockServiceTest.java</code></p> <pre><code>package demoapp;\n\nimport demoapp.service.SaludoService;\nimport org.junit.jupiter.api.Test;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.mock.mockito.MockBean;\nimport org.springframework.test.web.servlet.MockMvc;\n\nimport static org.hamcrest.Matchers.containsString;\nimport static org.mockito.Mockito.when;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\nimport static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\nimport static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n\n@SpringBootTest\n@AutoConfigureMockMvc\npublic class MockServiceTest {\n\n    @Autowired\n    private MockMvc mockMvc;\n\n    // Podemos tambi\u00e9n mockear el servicio\n    @MockBean\n    private SaludoService service;\n\n    @Test\n    public void greetingShouldReturnMessageFromService() throws Exception {\n\n        // Y especificar lo que debe devolver una llamada a uno de sus m\u00e9todos\n        when(service.saluda(\"Domingo\")).thenReturn(\"Hola Mock Domingo\");\n\n        this.mockMvc.perform(get(\"/saludo/Domingo\"))\n                .andExpect(status().isOk())\n                .andExpect(content().string(containsString(\"Hola Mock Domingo\")));\n    }\n}\n</code></pre>"},{"location":"01-intro-spring-boot/intro-spring-boot.html#5-referencias","title":"5. Referencias","text":"<p>Puedes encontrar la documentaci\u00f3n de referencia de Spring Boot y Spring en las siguientes p\u00e1ginas, en la pesta\u00f1a Learn:</p> <ul> <li>Spring Boot</li> <li>Spring </li> </ul> <p>Tambi\u00e9n podemos encontrar tambi\u00e9n una extensa cantidad de tutoriales y gu\u00edas r\u00e1pidas en la web de Spring, en la url https://spring.io/guides.</p> <p>En concreto, hemos usado las siguientes referencias para construir esta primera aplicaci\u00f3n ejemplo:</p> <ul> <li>Building an Application with Spring Boot</li> <li>Serving Web Content with Spring  MVC</li> <li>Handling Form Submission</li> <li>Validating Form Input</li> <li>Spring Boot Reference Guide 2.6.10   (HTML, PDF)</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html","title":"Enunciado de la pr\u00e1ctica","text":""},{"location":"01-intro-spring-boot/practica1.html#practica-1-primera-aplicacion-con-spring-boot","title":"Pr\u00e1ctica 1: Primera aplicaci\u00f3n con Spring Boot","text":"<p>En esta pr\u00e1ctica tendremos un primer contacto con Spring Boot, Git y Docker. Ser\u00e1 una pr\u00e1ctica de una semana.</p> <p>Los objetivos principales son:</p> <ul> <li>Empezar a conocer Spring Boot, ejecutando una sencilla aplicaci\u00f3n hola mundo en Spring Boot.</li> <li>Empezar a conocer el framework de plantillas Thymeleaf, realizando   peque\u00f1as modificaciones en la aplicaci\u00f3n que usen un formulario.</li> <li>Trabajar de forma regular, realizando peque\u00f1os commits que se deben   subir al repositorio personal de la asignatura en GitHub.</li> <li>Crear una aplicaci\u00f3n desplegable usando Docker y publicar el contenedor en   DockerHub</li> </ul> <p>La duraci\u00f3n de la pr\u00e1ctica es de 1 semana, la fecha l\u00edmite de entrega es el d\u00eda 19 de septiembre y su puntuaci\u00f3n es de 0,4 puntos en la nota final de la asignatura.</p>"},{"location":"01-intro-spring-boot/practica1.html#1-instalacion-de-software","title":"1. Instalaci\u00f3n de software","text":"<p>Vamos a trabajar bastante con el terminal. En Linux o macOS podemos usar el terminal que viene con el sistema. En Windows se puede usar el terminal Git Bash que se instala en la instalaci\u00f3n de Git para Windows.</p> <p>Es posible desarrollar la pr\u00e1ctica en cualquier sistema operativo. Debemos instalar el siguiente software:</p> <ul> <li>Git</li> <li>Java JDK 8 o posterior</li> <li>IntelliJ Ultimate</li> </ul> <p>No puedo ayudar con posibles problemas en Windows</p> <p>Aunque en los apuntes aparezca informaci\u00f3n sobre c\u00f3mo trabajar desde Windows, no puedo garantizar que las instrucciones funcionen correctamente en todas las posibles configuraciones (aunque deber\u00edan funcionar bien, por estar trabajando con tecnolog\u00eda Java), ni te podr\u00e9 ayudar con posibles problemas, porque no es un sistema operativo que maneje habitualmente. Por tanto, si tienes Windows, te recomiendo que instales una m\u00e1quina virtual Linux y la uses para la pr\u00e1ctica.</p>"},{"location":"01-intro-spring-boot/practica1.html#intellij-ultimate","title":"IntelliJ Ultimate","text":"<p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p>"},{"location":"01-intro-spring-boot/practica1.html#alta-en-github-educativo","title":"Alta en GitHub educativo","text":"<p>Darse de alta en GitHub con el correo de la UA y solicitar el registro como estudiante para obtener beneficios como el uso de GitHub Pro (que incluye Copilot) y poder solicitar el GitHub Student Developer pack con ofertas como $200 en  servidores de Digital Ocean.</p>"},{"location":"01-intro-spring-boot/practica1.html#instalacion-basica","title":"Instalaci\u00f3n b\u00e1sica","text":""},{"location":"01-intro-spring-boot/practica1.html#linux","title":"Linux","text":"<p>Para instalar el software en Linux.</p> <ul> <li>Instalar Git y Java:</li> </ul> <pre><code>$ sudo apt install git\n$ sudo apt install default-jdk\n</code></pre> <ul> <li>Instalar IntelliJ Ultimate</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html#macos","title":"macOS","text":"<ul> <li>Git y Java vienen instalados con el sistema operativo. </li> <li>Instalar IntelliJ Ultimate</li> </ul>"},{"location":"01-intro-spring-boot/practica1.html#windows","title":"Windows","text":"<p>Es recomendable instalar git for Windows, que adem\u00e1s de Git instala Git BASH, un terminal Bash integrado en Windows.</p> <p>Adem\u00e1s, hay que instalar Java e IntelliJ Ultimate.</p>"},{"location":"01-intro-spring-boot/practica1.html#despues-de-la-instalacion-basica","title":"Despu\u00e9s de la instalaci\u00f3n b\u00e1sica","text":"<p>Es f\u00e1cil probar que funciona el software instalado. Basta con ejecutar desde el terminal:</p> <pre><code>$ git --version\n$ java -version (imprime la versi\u00f3n de Java)\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#configuracion-del-prompt-para-que-aparezca-la-rama-de-git","title":"Configuraci\u00f3n del prompt para que aparezca la rama de Git","text":"<p>Bash</p> <p>Es tambi\u00e9n bastante \u00fatil configurar el prompt para que aparezca la rama del repositorio Git en que nos encontramos. Para ello se debe a\u00f1adir en el fichero <code>$HOME/.bashrc</code> (linux y Git Bash Windows) o <code>$HOME/.bash_profile</code> (macOS con shell <code>bash</code>) :</p> <pre><code>parse_git_branch() {\n    git branch 2&gt; /dev/null | sed -e '/^[^*]/d' -e 's/* \\(.*\\)/ (\\1)/'\n}\nexport PS1=\"\\[\\e[37m\\]\\A \\[\\e[m\\]\\[\\033[32m\\]\\W\\[\\033[33m\\]\\$(parse_git_branch)\\[\\033[00m\\] $ \"\n</code></pre> <p>Podemos encontrar m\u00e1s opciones de configuraci\u00f3n del prompt en muchas p\u00e1ginas en Internet. Por ejemplo aqu\u00ed.</p> <p>Zsh</p> <p>Si trabajas con el shell <code>zsh</code> que viene por defecto en MacOS, debes a\u00f1adir en el fichero <code>.zshrc</code> lo siguiente:</p> <pre><code>parse_git_branch() {\n    git branch 2&gt; /dev/null | sed -n -e 's/^\\* \\(.*\\)/ [\\1]/p'\n}\nsetopt PROMPT_SUBST\nexport PROMPT='%1~%F{green}$(parse_git_branch)%f %% '\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#2-creacion-del-repositorio-github-con-la-practica","title":"2. Creaci\u00f3n del repositorio GitHub con la pr\u00e1ctica","text":"<p>Para inicializar el repositorio de GitHub en el que vas a trabajar en esta pr\u00e1ctica debes seguir los siguientes pasos:</p> <ol> <li> <p>Inicializa tu nombre de usuario y tu correo en Git. El nombre de    usuario ser\u00e1 el nombre que aparecer\u00e1 en los commits. Pon tu nombre    y apellido.</p> <pre><code>$ git config --global user.name \"Pepe Perez\"\n$ git config --global user.email pepe.perez@example.com\n</code></pre> </li> <li> <p>Crea una cuenta en GitHub. Puedes usar el nombre de usuario que    quieras (o usar el que ya tienes), pero escribe correctamente tu    nombre y apellidos en el perfil usando la opci\u00f3n Settings &gt;    Profile y actualizando el campo Name.</p> </li> <li> <p>Una vez logeado en GitHub, pincha en el enlace con una invitaci\u00f3n    que compartiremos en el foro de Moodle. Deber\u00e1s aceptar las    peticiones de GitHub Classroom y podr\u00e1s aceptar la pr\u00e1ctica Spring    Boot Demo App. </p> <p></p> <p>Se crear\u00e1 autom\u00e1ticamente el repositorio <code>springboot-demo-app-&lt;usuario&gt;</code> en la organizaci\u00f3n mads-ua-23-24. Es un repositorio privado al que tienes acceso t\u00fa y el profesor. Contiene el c\u00f3digo inicial del proyecto demostraci\u00f3n de Spring Boot (es una copia del repositorio domingogallardo/spring-boot-demoapp).</p> <p></p> <p>Es importante que tengas en cuenta que el repositorio reci\u00e9n creado no reside en tu cuenta, sino en la organizaci\u00f3n <code>mads-ua-23-24</code>. Puedes acceder a \u00e9l desde el dashboard de GitHub que aparece cuando te logeas o pulsando en el icono de GitHub:</p> <p></p> </li> <li> <p>El profesor te invitar\u00e1 a formar parte de la organizaci\u00f3n <code>mads-ua-23-24</code>    y recibir\u00e1s un mensaje de correo electr\u00f3nico en el que deber\u00e1s    aceptar esta invitaci\u00f3n. Tambi\u00e9n se puede aceptar la invitaci\u00f3n    accediendo a https://github.com/mads-ua-23-24.</p> </li> </ol>"},{"location":"01-intro-spring-boot/practica1.html#3-aplicacion-demo-de-spring-boot","title":"3. Aplicaci\u00f3n Demo de Spring Boot","text":"<p>Haremos una primera pr\u00e1ctica sencilla en la que primero pondremos en marcha y publicaremos una aplicaci\u00f3n inicial en Spring Boot y despu\u00e9s a\u00f1adiremos alguna funcionalidad.</p> <p>En el documento Introducci\u00f3n a Spring Boot se explica c\u00f3mo ejecutar una aplicaci\u00f3n Spring Boot y c\u00f3mo lanzar sus tests. Tambi\u00e9n se proporciona una introducci\u00f3n a los distintos componentes de la aplicaci\u00f3n. Debes leerlo y aprender el funcionamiento b\u00e1sico de este framework.</p>"},{"location":"01-intro-spring-boot/practica1.html#construccion-y-ejecucion-de-la-aplicacion","title":"Construcci\u00f3n y ejecuci\u00f3n de la aplicaci\u00f3n","text":"<p>Lo primero que deber\u00e1s hacer ser\u00e1 descargar la aplicaci\u00f3n  <code>demo-spring-boot</code> que tienes en el repositorio creado en el punto  anterior y comprobar que funciona correctamente. Debes hacer lo siguiente:</p> <ol> <li> <p>Configura un Personal Access    Token (PAT)    en GitHub para poder autenticarte desde el terminal. Dale todos los    permisos de acceso a repositorios y copia la clave generada. Ser\u00e1    la contrase\u00f1a que deber\u00e1s introducir cuando un comando git te la    pida.</p> </li> <li> <p>Descarga en tu ordenador el repositorio creado en GitHub en el apartado    anterior, usando el comando <code>git clone</code>:</p> <pre><code>$ git clone https://github.com/mads-ua-23-24/springboot-demo-app-&lt;usuario&gt;.git\n</code></pre> <p>Cuando git te pida autenticaci\u00f3n, usa como nombre de usuario tu usuario de GitHub y como contrase\u00f1a el PAT que has creado anteriormente.</p> </li> </ol> <p>Una vez descargado el repositorio con la aplicaci\u00f3n deber\u00e1s ejecutarla desde la l\u00ednea de comandos, probar los tests e importarla en IntelliJ y ejecutar y depurar con el IDE la aplicaci\u00f3n y los tests.</p> <ol> <li> <p>Desde el directorio donde est\u00e1 la aplicaci\u00f3n, probamos todos sus    tests usando el Maven Wrapper:</p> <pre><code>$ ./mvnw test\n</code></pre> </li> <li> <p>Para poner en marcha la aplicaci\u00f3n la arrancamos como una    aplicaci\u00f3n Java:</p> <pre><code>$ ./mvnw package\n$ java -jar target/demoapp-0.0.1-SNAPSHOT.jar \n</code></pre> <p>Tambi\u00e9n podemos lanzarla usando el plugin <code>spring-boot</code> de Maven:</p> <pre><code>$ ./mvnw spring-boot:run\n</code></pre> <p>La aplicaci\u00f3n se arranca por defecto en el puerto local 8080. Una vez arrancada la aplicaci\u00f3n podemos conectarnos desde un navegador a sus p\u00e1ginas de inicio.</p> <p>En el caso de la aplicaci\u00f3n demo descargada, podemos probar las siguientes p\u00e1ginas:</p> <ul> <li>http://localhost:8080</li> <li>http://localhost:8080/saludo/Pepito</li> <li>http://localhost:8080/saludoplantilla/Pepito</li> <li>http://localhost:8080/saludoform</li> </ul> </li> </ol> <p>Recomendamos hacer el desarrollo usando el IDE IntelliJ Ultimate. Aunque es de pago, es posible obtener una licencia de estudiante usando la direcci\u00f3n de correo de la UA.</p> <p>Tambi\u00e9n es recomendable instalar el plugin GithHub Copilot para JetBrains para trabajar con este asistente de IA como ayudante de c\u00f3digo. Tras instalar el plugin deber\u00e1s activarlo introduciendo tu usuario de GitHub.</p> <p>Puedes trabajar de forma gratuita con GitHub Copilot d\u00e1ndote de alta en el GitHub Student Developer Pack.</p> <ol> <li> <p>Abre proyecto el en IntelliJ. Debes importar el directorio donde se    encuentre el fichero <code>pom.xml</code>. Se puede hacer desde la pantalla de    bienvenida de IntelliJ con la opci\u00f3n Import Project o usando la    opci\u00f3n \"File &gt; New &gt; Project from Existing    Sources. Aparecer\u00e1 la pantalla de importaci\u00f3n y seleccionamos el    importador Maven:</p> <p></p> <p>IntelliJ abre el proyecto correctamente:</p> <p></p> <p>Podemos ejecutarlo abriendo un terminal y lanz\u00e1ndolo con Maven. O tambi\u00e9n desde la configuraci\u00f3n de Run que ha creado IntelliJ al realizar la importaci\u00f3n:</p> <p></p> <p>Se abrir\u00e1 un panel de ejecuci\u00f3n desde el que se puede parar la aplicaci\u00f3n, volverla a lanzar, etc:</p> <p></p> <p>Desde la configuraci\u00f3n de Run tambi\u00e9n podemos depurar el proyecto, pulsando el bot\u00f3n de depuraci\u00f3n.</p> <p></p> </li> <li> <p>Lanza los tests desde el propio IntelliJ, pulsando en el    panel del proyecto sobre el directorio de tests con el bot\u00f3n    derecho. Los tests se lanzar\u00e1n y aparecer\u00e1 un panel en el que se    mostrar\u00e1 si pasan correctamente (verde) o no.</p> <p></p> </li> </ol> <p>Por \u00faltimo, haz alg\u00fan peque\u00f1o cambio a la aplicaci\u00f3n. </p> <ol> <li> <p>Cambia el mensaje de saludo que da el controller de la ra\u00edz para incluir tu nombre.     Comprueba que los tests pasan (modif\u00edcalos si no es as\u00ed) y que la aplicaci\u00f3n funciona    correctamente.</p> <p></p> </li> </ol>"},{"location":"01-intro-spring-boot/practica1.html#dockerizacion-de-la-aplicacion","title":"Dockerizaci\u00f3n de la aplicaci\u00f3n","text":"<p>Docker es un software de virtualizaci\u00f3n que utiliza el propio sistema operativo compartimentado y permite gestionar contenedores (similares a las m\u00e1quinas virtuales) de forma mucho menos pesada y r\u00e1pida que con sistemas de virtualizaci\u00f3n tradicionales como VirtualBox. </p> <p>Las m\u00e1quinas Docker son muy eficientes porque comparten los servicios del sistema operativo en el que se ejecutan, utilizando menos recursos que las m\u00e1quinas virtuales tradicionales. </p> <p>Docker proporciona un sistema muy sencillo de distribuci\u00f3n y puesta en producci\u00f3n de software, ya que las m\u00e1quinas Docker pueden ser distribuidas usando repositorios (como Docker Hub) y ejecutadas en cualquier ordenador que tenga instalado el Docker Engine.</p> <p>La tecnolog\u00eda es muy popular y se usa en gran cantidad de empresas de desarrollo para simplificar la ejecuci\u00f3n en en m\u00faltiples entornos y para que los contenedores (m\u00e1quinas Docker en ejecuci\u00f3n) se pueden configurar y combinar o ejecutar en clusters usando herramientas como Kubernetes.</p> <p>En nuestro caso, vamos a construir una m\u00e1quina Docker basada en la aplicaci\u00f3n demo. Posteriormente, la publicaremos en Docker Hub y  la desplegaremos en un host para ponerla en producci\u00f3n.</p> <ol> <li> <p>Instala Docker    Desktop. Los    usuarios de Linux deb\u00e9is seguir las instrucciones de esta    p\u00e1gina para    instalar Docker Engine. Usaremos la l\u00ednea de comando para lanzar    los comandos Docker. La aplicaci\u00f3n Docker Desktop permite usar una    interfaz de usuario para interactuar con im\u00e1genes y contenedores,    pero no proporciona ninguna funcionalidad que no est\u00e9 disponible en    la l\u00ednea de comando.</p> <p>Una vez instalado puedes probar el tutorial r\u00e1pido (2 minutos)  desde Docker Desktop para comprobar que todo funciona  correctamente. Tambi\u00e9n puedes desde el terminal comprobar la  versi\u00f3n de Docker instalada:</p> <pre><code>$ docker version\n</code></pre> </li> <li> <p>Crea una cuenta de usuario en Docker    Hub. De esta forma tendr\u00e1s un repositorio    en el que podr\u00e1s subir las im\u00e1genes de las m\u00e1quinas Docker que    construyas. Deber\u00e1s dar un nombre de usuario que ser\u00e1 el que    utilizar\u00e1s para publicar estas im\u00e1genes.</p> </li> <li> <p>Crea un fichero llamado <code>Dockerfile</code> (sin extensi\u00f3n) en el   directorio ra\u00edz de la aplicaci\u00f3n con el siguiente contenido:</p> <p>Fichero <code>./Dockerfile</code>:</p> <pre><code>FROM openjdk:8-jdk-alpine\nCOPY target/*.jar app.jar\nENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/urandom\",\"-jar\",\"/app.jar\"]\n</code></pre> <p>El fichero <code>Dockerfile</code> consiste en un conjunto secuencial de instrucciones con las que se construye la m\u00e1quina Docker:</p> <ul> <li><code>FROM</code>: este comando indica la m\u00e1quina base sobre la que se van   a ejecutar el resto de comandos. En nuestro caso una m\u00e1quina de   la organizaci\u00f3n <code>openjdk</code> que contiene la distribuci\u00f3n 8 del   <code>Java Development Kit (JDK)</code> y que est\u00e1 basada en una   distribuci\u00f3n linux Alpine. El primer paso de la construcci\u00f3n de   nuestra m\u00e1quina Docker consiste por tanto en descargar esta   m\u00e1quina <code>openjdk:8-jdk-alpine</code> y usarla como m\u00e1quina base.</li> <li><code>COPY</code>: este comando indica que se debe copiar un fichero o   conjunto de ficheros de la m\u00e1quina host (el directorio en el que   estamos) en la m\u00e1quina base. En este caso se copia el fichero   JAR que constituye nuestra aplicaci\u00f3n que est\u00e1 situado en el   directorio <code>./target</code> y se copia en la m\u00e1quina Docker con el   nombre <code>app.jar</code>.</li> <li> <p><code>ENTRYPOINT</code>: este comando indica el comando a ejecutar cuando se   pone en marcha la m\u00e1quina Docker. En este caso se lanza la   aplicaci\u00f3n (<code>app.jar</code>) con el comando <code>java -jar</code>. </p> <p>El modificador <code>-Djava.security.egd</code> hace que se inicialice el generador de n\u00fameros aleatorios de Java usando el fichero del sistema <code>/dev/urandom</code> en lugar del fichero por defecto <code>/dev/random</code>. Es necesario para resolver un bug que aparece al ejecutar el contenedor en servidores como los alojados en DigitalOcean.</p> </li> </ul> </li> <li> <p>Vuelve a compilar la aplicaci\u00f3n para asegurarte de que se genera el fichero    JAR que la contiene. Este fichero es que vamos a dockerizar.</p> <pre><code>$ ./mvnw package\n$ ls -l ./target/*.jar\n./target/demoapp-0.0.1-SNAPSHOT.jar\n</code></pre> </li> <li> <p>Ya puedes construir la m\u00e1quina Docker con el siguiente comando,   desde el directorio ra\u00edz de la aplicaci\u00f3n (en el que debe estar el   fichero <code>Dockerfile</code> anterior):</p> <pre><code>$ docker build -t &lt;usuario-docker&gt;/spring-boot-demoapp . \n</code></pre> <p>Comprueba que la imagen se ha creado correctamente. Debe aparecer en el Docker Desktop y con el comando <code>docker image ls</code>:</p> <pre><code>$ docker image ls \nREPOSITORY                            TAG\ndomingogallardo/spring-boot-demoapp   latest \n</code></pre> </li> <li> <p>Pon en marcha un la imagen con la aplicaci\u00f3n:</p> <pre><code>$ docker run -p 8080:8080 &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>El comando <code>docker run</code> pone en marcha la imagen indicada, creando lo que se denomina un contenedor Docker. Es similar a una m\u00e1quina virtual en ejecuci\u00f3n. El par\u00e1metro <code>-p 8080:8080</code> indica que el puerto interno 8080 del contenedor se va a mapear en el puerto 8080 del host. De esta forma podremos conectarnos desde el host a la aplicaci\u00f3n Spring Boot en funcionamiento.</p> <p>Ver\u00e1s que en la consola aparecen los mensajes de salida de la aplicaci\u00f3n Spring Boot que se ejecuta en el contenedor.</p> <p>Prueba a abrir un navegador y conectarte a la URL localhost:8080. Deber\u00e1s ver el mensaje de saludo de la aplicaci\u00f3n ejecut\u00e1ndose en el contendor.</p> <p>Haciendo <code>ctrl+c</code> puedes parar el contenedor. El efecto es similar a suspender una m\u00e1quina virtual. Puedes ver el identificador del contenedor con el comando:</p> <p><pre><code>$ docker container ls -a\nCONTAINER ID   IMAGE                NAMES\n5bd9d0b055a9   domingogallardo/spring-boot-demoapp  inspiring_feynman\n</code></pre> Puedes usar tanto el ID del contenedor (<code>5bd9d0b055a9</code>) como su nombre (<code>inspiring_feynman</code>) para identificarlo.</p> <p>Estando parado, puedes volver a poner en marcha el contenedor haciendo:</p> <pre><code>$ docker container start &lt;identificador&gt;\n</code></pre> <p>Tambi\u00e9n podemos parar el contenedor:</p> <pre><code>$ docker container stop &lt;identificador&gt;\n</code></pre> <p>Y borrarlo definitivamente con </p> <pre><code>$ docker container rm &lt;identificador&gt;\n</code></pre> <p>Otros comandos \u00fatiles de Docker son:</p> <ul> <li><code>docker run -d</code> : lanza el contendor en modo background.</li> <li><code>docker run --rm</code> : lanza el contenedor de forma que al pararlo   se borra autom\u00e1ticamente.</li> <li><code>docker container logs &lt;identificador&gt;</code> : muestra los logs del   contenedor indicado.</li> </ul> <p>En la aplicaci\u00f3n Docker Engine podemos realizar tambi\u00e9n muchos de estos comandos interactuando directamente con la interfaz. Pru\u00e9balo.</p> </li> <li> <p>Ahora que has comprobado que el fichero <code>Dockerfile</code> funciona    correctamente debes a\u00f1adirlo a git y subirlo al respositorio    GitHub:</p> <pre><code>$ git status\n$ git add .\n$ git status\n$ git commit -m \"A\u00f1adido Dockerfile\"\n$ git push\n</code></pre> </li> <li> <p>Vamos a terminar publicando la imagen en tu cuenta de Docker Hub.</p> <ul> <li> <p>Ve a Docker Hub y log\u00e9ate.</p> </li> <li> <p>Crea un repositorio p\u00fablico con el nombre <code>spring-boot-demoapp</code>. En   ese repositorio vas a subir la imagen con el mismo nombre. En un   repositorio Docker puedes mantener m\u00faltiples versiones de una misma   imagen, usando tags.</p> </li> <li> <p>Una vez creado el repositorio puedes publicar la imagen en \u00e9l   loge\u00e1ndote desde la l\u00ednea de comando (introduce tu usuario y   contrase\u00f1a de Docker Hub) y con el comando <code>docker push</code>:</p> </li> </ul> <pre><code>$ docker login\n$ docker push &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>Ver\u00e1s que autom\u00e1ticamente se asigna la etiqueta <code>latest</code>   (etiqueta por defecto) a la imagen y que \u00e9sta se sube al   repositorio. Podr\u00edas asignar una etiqueta espec\u00edfica a la imagen   con el comando <code>docker tag</code>. Por ejemplo, si quisi\u00e9ramos fijar   esta imagen con la versi\u00f3n <code>1.0</code> podr\u00edamos hacerlo con el   siguiente comando:</p> <pre><code>$ docker tag &lt;usario-docker&gt;/spring-boot-demoapp &lt;usuario-docker&gt;/spring-boot-demoapp:1.0\n</code></pre> <ul> <li>Comprueba en la p\u00e1gina web del repositorio que se   ha subido. El repositorio es p\u00fablico y cualquiera puede   descargar la imagen haciendo:</li> </ul> <pre><code>$ docker pull &lt;usuario-docker&gt;/spring-boot-demoapp\n</code></pre> <p>Al no indicar la etiqueta, se descargar\u00eda la imagen etiquetada   con <code>latest</code>. Si quisi\u00e9ramos descargar una versi\u00f3n concreta   habr\u00eda que especificar la etiqueta:</p> <pre><code>$ docker pull &lt;usuario-docker&gt;/spring-boot-demoapp:1.0\n</code></pre> </li> <li> <p>Escribe en el fichero <code>README.md</code> del repositorio GitHub un enlace a la     vista p\u00fablica de la imagen en Docker Hub. La vista p\u00fablica tiene el     formato     https://hub.docker.com/r/domingogallardo/spring-boot-demoapp.</p> </li> </ol> <p>Importante</p> <p>Aseg\u00farate de que es posible acceder al enlace de tu imagen docker  sin estar logeado en DockerHub. Abre otro navegador diferente en el que no est\u00e9s logeado y prueba que el enlace funciona correctamente. Ese enlace es el que voy a usar para comprobar el funcionamiento correcto de la pr\u00e1ctica.</p>"},{"location":"01-intro-spring-boot/practica1.html#4-estudia-el-funcionamiento-de-la-aplicacion-y-su-arquitectura","title":"4. Estudia el funcionamiento de la aplicaci\u00f3n y su arquitectura","text":"<p>En el documento Introducci\u00f3n a Spring Boot se comenta el c\u00f3digo fuente de la aplicaci\u00f3n Spring Boot con la que estamos trabajando. L\u00e9elo despacio, revisando tambi\u00e9n el c\u00f3digo fuente, para entender los aspectos b\u00e1sicos (controladores, servicios, inyecci\u00f3n de dependencias, plantillas) del funcionamiento de Spring Boot.</p> <p>Estudia tambi\u00e9n despacio el funcionamiento de los tests y el funcionamiento del formulario y la validaci\u00f3n. </p> <p>Puedes ver un ejemplo adicional de validaci\u00f3n de un formulario en el repositorio domingogallardo/spring-boot-validate.</p> <p>Ver\u00e1s tambi\u00e9n ah\u00ed varios ejemplos de tests en los que se realiza una petici\u00f3n POST pasando par\u00e1metros y se obtiene informaci\u00f3n del modelo resultante, llamando al m\u00e9todo <code>model()</code>. El siguiente es un ejemplo de uno de los tests:</p> <pre><code>@Test\npublic void checkPersonInfoWhenNameTooShortThenFailure() throws Exception {\n    mockMvc.perform(post(\"/\")\n                    .param(\"name\", \"R\")\n                    .param(\"age\", \"20\"))\n            .andExpect(model().hasErrors());\n}\n</code></pre>"},{"location":"01-intro-spring-boot/practica1.html#5-anadimos-alguna-funcionalidad-sencilla-a-la-aplicacion","title":"5. A\u00f1adimos alguna funcionalidad sencilla a la aplicaci\u00f3n","text":"<p>Para demostrar que comprendes el funcionamiento de una aplicaci\u00f3n Spring Boot, debes a\u00f1adir alguna funcionalidad sencilla a la aplicaci\u00f3n Demo. Debes definir t\u00fa la funcionalidad a implementar. Por ejemplo, cualquiera de los siguientes ejemplos o alguno similar que se te ocurra:</p> <ul> <li>Pal\u00edndroma: lee una palabra y comprueba si es pal\u00edndroma.</li> <li>N\u00famero par: lee un n\u00famero y comprueba si es par</li> <li>Cuadrado: lee dos n\u00fameros y comprueba si el segundo es el cuadrado del primero</li> <li>Calculadora: lee un par de n\u00fameros y una operaci\u00f3n y devuelve el resultado.</li> </ul> <p>La aplicaci\u00f3n debe realizar lo siguiente:</p> <ul> <li>Leer datos de un formulario usando Thymeleaf y realizar alguna validaci\u00f3n.</li> <li>Llamar a un m\u00e9todo de servicio que procese los datos le\u00eddos.</li> <li>Mostrar el resultado devuelto por el servicio en una p\u00e1gina Thymeleaf.</li> <li>Tests de la capa de servicio y de la capa de presentaci\u00f3n   (controllers web).</li> <li>En la p\u00e1gina principal de la aplicaci\u00f3n debe aparecer tu nombre y apellidos.</li> </ul> <p>Muy importante, debemos desarrollar la aplicaci\u00f3n en peque\u00f1os commits. Cada commit debe compilar correctamente y a\u00f1adir una peque\u00f1a funcionalidad o debe realizar una refactorizaci\u00f3n en la que no se incluye ninguna nueva funcionalidad pero se mejora el c\u00f3digo. </p> <p>Debemos subir los commits al repositorio de GitHub.</p> <p>Peque\u00f1os commits</p> <p>Para la realizaci\u00f3n correcta de la pr\u00e1ctica debes ir construyendo la aplicaci\u00f3n a base de peque\u00f1os commits que incrementen su funcionalidad. Si no has trabajado nunca de esta forma te resultar\u00e1 algo complicado al principio, pero poco a poco ir\u00e1s cogi\u00e9ndole el tranquillo.</p> <p>La idea es que antes de emepezar a escribir el c\u00f3digo debes tener claro qu\u00e9 cosas quieres hacer. Veremos que la t\u00e9cnica de TDD nos ayuda a ello, pero por ahora no vamos a usarla. </p> <p>Por ejemplo, si queremos hacer una aplicaci\u00f3n que compruebe si una palabra  es pal\u00edndroma necestaremos una funci\u00f3n en un servicio que haga esa comprobaci\u00f3n. Procedemos entonces a escribir c\u00f3digo para implementarla. Antes de grabar el commit debemos comprobar que funciona correctamente. \u00bfC\u00f3mo lo hacemos? Podemos hacerlo de dos formas: crear un sencillo controller que la llame a esa funci\u00f3n con un ejemplo concreto o crear un test. Una vez comprobado que funciona correctamente la funci\u00f3n grabamos el commit.</p> <p>Una vez terminada la capa de servicio deberemos programar el controller y el formulario para usar la aplicaci\u00f3n. Tambi\u00e9n lo debemos hacer poco a poco, con commits peque\u00f1os. Por ejemplo, primero podemos programar una versi\u00f3n sencilla (primer commit), despu\u00e9s podemos a\u00f1adir validaciones al formulario (segundo commit) y por \u00faltimo podemos hacer alg\u00fan retoque del aspecto de la aplicaci\u00f3n (tercer commit).</p> <p>Cuando termines de implementar todos los tests (cuantos m\u00e1s mejor) y compruebes que funcionan correctamente y que la aplicaci\u00f3n funciona bien en local, debes crear la m\u00e1quina Docker con la etiqueta <code>final</code> y subirla a tu repositorio DockerHub.</p>"},{"location":"01-intro-spring-boot/practica1.html#6-comandos-git","title":"6. Comandos Git","text":"<p>Comandos Git necesarios para realizar la pr\u00e1ctica:</p> <ul> <li>git clone</li> <li>git status</li> <li>git add</li> <li>git commit</li> <li>git push</li> <li>git log</li> </ul> <p>Puedes encontrar m\u00e1s informaci\u00f3n sobre estos comandos en el documento Resumen de comandos Git que resume los conceptos m\u00e1s importantes de Git necesarios para estas primeras pr\u00e1cticas de la asignatura.</p>"},{"location":"01-intro-spring-boot/practica1.html#7-entrega","title":"7. Entrega","text":"<ul> <li> <p>La pr\u00e1ctica tiene una duraci\u00f3n de 1 semana y debe estar terminada   el martes 19 de septiembre.</p> </li> <li> <p>La calificaci\u00f3n de la pr\u00e1ctica tiene un peso de un 4% en la nota   final de la asignatura.</p> </li> </ul> <p>Para realizar la entrega debes hacer lo siguiente:</p> <ul> <li>Realizar la aplicaci\u00f3n en el repositorio creado e ir subiendo los   commits a GitHub conforme se van realizando.</li> <li>Actualizar el fichero <code>README.md</code> con el enlace a la vista p\u00fablica de la   imagen subida DockerHub. En esa p\u00e1gina debe estar la imagen con la etiqueta   <code>final</code>. El formato de la URL debe ser   <code>https://hub.docker.com/r/&lt;usuario-docker&gt;/spring-boot-demoapp</code>.</li> <li>A\u00f1adir una p\u00e1gina de documentaci\u00f3n <code>doc/practica1.md</code> en la que se   explique brevemente tanto la funcionalidad como la implementaci\u00f3n y tests   a\u00f1adidos. Se debe incluir tambi\u00e9n la URL  de los repositorios en GitHub y en Docker   Hub. Deber\u00e1s escribir esta documentaci\u00f3n en Markdown. Tienes   disponible en GitHub una breve pero \u00fatil introducci\u00f3n a   Markdown.</li> <li>Entregar en Moodle un ZIP con el directorio del proyecto (incluyendo el   directorio .git con el repositorio git), despu\u00e9s de haber hecho   <code>./mvnw clean</code> para eliminar los binarios compilados.</li> </ul> <p>Para la evaluaci\u00f3n se tendr\u00e1 en cuenta:</p> <ul> <li>Desarrollo continuo (los commits deben realizarse a lo largo de   toda la semana y no dejar todo para el \u00faltimo d\u00eda).</li> <li>Commits peque\u00f1os, cada commit debe ser funcional e introducir alg\u00fan elemento   nuevo o realizar alguna refactorizaci\u00f3n.</li> <li>Correcto desarrollo de la metodolog\u00eda.</li> <li>Dise\u00f1o e implementaci\u00f3n del c\u00f3digo y de los tests de las   caracter\u00edsticas desarrolladas.</li> </ul> <p>Penalizaci\u00f3n por realizar la pr\u00e1ctica el \u00faltimo d\u00eda</p> <p>En la asignatura se recompensa el trabajo continuo y la realizaci\u00f3n de los commits a lo largo de toda la semana. Si se realiza todo el trabajo en el \u00faltimo d\u00eda se tendr\u00e1 una penalizaci\u00f3n en la nota.</p>"}]}